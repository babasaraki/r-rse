# Python Packaging {#py-rse-package-py}

```{r py-rse-package-py-setup, include=FALSE}
source(here::here("_common.R"))
```

> Another response of the wizards,
> when faced with a new and unique situation,
> was to look through their libraries to see if it had ever happened before.
> This was… a good survival trait.
> It meant that in times of danger you spent the day sitting very quietly in a building with very thick walls.
>
> — Terry Pratchett

The more software you write,
the more you realize that a programming language is a way to build and combine software libraries.
Every widely-used language now has an online repository
from which people can download and install those libraries.
This lesson shows you how to use Python's tools to create and share libraries of your own.

This material is based in part on [Python 102][python-102] by [Ashwin Srinath][srinath-ashwin].

We'll continue with our Zipf's Law project,
which should include the following files:

```text
├── CONDUCT.md
├── LICENSE.md
├── Makefile
├── README.md
├── bin
│   ├── book_summary.sh
│   ├── collate.py
│   ├── countwords.py
│   ├── mymodule.py
│   ├── plotcounts.py
│   └── rcparams.yml
├── data
│   ├── README.md
│   ├── dracula.txt
│   └── ...
├── results
│   ├── dracula.csv
│   ├── dracula.png
│   └── ...
└── tests
    └── test_countwords.py
    └── ...
```

## How can I create an installable Python package? {#py-rse-package-py-package}

A package is essentially a few Python scripts in a specific directory structure
coupled with installation instructions for the computer.
Python packages can come from various sources.
Many that you will use are part of the standard distribution,
but packages can be created by anyone
and there are thousands that can be downloaded and installed from online repositories.
Note that you will sometimes hear packages referred to as "modules".
These two words are often used interchangeably.
Technically,
a package is a folder that contains modules (scripts),
which in turn contains functions (code).

A general package folder hierarchy looks like this

```text
pkg_name
├── pkg_name
│   ├── module1.py
│   └── module2.py
├── README.md
└── setup.py
```

which in our case would mean changing the name of `bin/` to `zipf`.

It may initially be confusing to have two folders with the same name
(the original project directory,
and the renamed `bin/`),
but it makes it easier to setup your project for installation
and it is the convention used by most Python projects.
Alternative directory structures are possible,
but in this chapter we're focusing on the approach we believe is the most beneficial to learn.

> You will often see Python packages containing a file with a special name: `__init__.py`.
> This was a requirement before Python 3.3,
> but is now only needed to execute code upon package import.
> Just as importing a module file executes the code in the module,
> importing a package executes the code in `__init__.py`.

For our scripts to work as a Python package,
we only need to make one important change to the code itself:
changing the syntax for how we import `mymodule`.
Currently,
both `collate.py` and `countwords.py` contains this line:

```python
import mymodule
```

This is called an implicit relative import,
because it is not clear whether there exists a Python package called `mymodule`
or there is a file in our local directory named `mymodule.py` (as in our case).
This ambiguity is not ideal
and when making a package we need to be more explicit and write:

```python
from zipf import mymodule
```

This is referred to as an absolute import,
since we are specifying the full location of `mymodule` inside the `zipf` package.
Absolute imports are the preferred way of importing your own code inside a package,
but you will probably also encounter explicit relative imports,
which can provide some advantages when restructuring large projects:

```python
from . import mymodule
```

Here,
the `.` makes it clear that `mymodule` exists in the current directory.

Python has several ways to build an installable package.
We will show how to use [setuptools][setuptools],
which is the lowest common denominator.
The setuptools approach we describe below will
allow everyone,
regardless of what python distribution they use,
to easily use your package.
To use `setuptools`,
we must create a file called `setup.py` in the directory *above* the root directory of the package:
The file `setup.py` must have exactly that name,
and must contain these lines:

```python
from setuptools import setup


setup(
    name='zipf',
    version='0.1',
    author='Amira Khan',
    packages=['zipf'])
```

We can add additional information later,
but this is enough to be able to install the package
from the local copy source code using standard tools.
However,
it is considered good practice to first create a separate, virtual Python environment
before installing our own packages.
This will allow us to test how our package installs in a clean Python environment,
rather that the current state of our primary Python environment.

> **Semantic Versioning**
>
> How do we decide what version number to use?
> Most software projects use semantic versioning for software releases,
> where a version number takes the form X.Y.Z and X, Y and Z are integers.
> X is the major version, Y is the minor version, and Z is the patch version.
> Major version zero (0.Y.Z) is for initial development, so we've started with 0.1.0.
> The very first stable public release would be version 1.0.0.
> In general, the version number is incremented as follows:
>
> -   Increment `major` every time there's an incompatible externally-visible change
> -   Increment `minor` when adding new functionality in a backwards-compatible manner (i.e. without breaking any existing code)
> -   Increment `patch` for backwards-compatible bug fixes that don't add any new features

> **Finding Packages**
>
> Above we have specified the folder name containing the packaging code to the `packages` parameter.
> This was straightforward for our package since we only have a single package directory.
> For more complex projects,
> it is good to know about the `find_packages()`[find-packages] function from `setuptools`,
> which can automatically find all packages by recursively searching the current directory.

## How can I create a virtual Python environment? {#py-rse-package-py-virtualenv}

It can be convenient to have several different Python environments that
you can switch between.
One reason is that you're probably working on
multiple projects at any given time,
each with different requirements
for Python packages,
and you want to keep them straight.

Another reason concerns us a bit more immediately.
We want to make sure that other people can successfully install and use our package.
That means:

- We want to be able to easily test install and uninstall our package,
  without affecting the entire Python environment.
- We want to answer problems people have with our package with something more helpful than
  "I don't know, it works for me".
  By installing and running our package in a completely empty environment,
  we can ensure that we're not accidentally relying on other packages being installed.

A very handy answer to both of those needs is a [virtual environment][virtual-environment].
A virtual environment is a layer on top of an existing Python installation.
Whenever Python needs to find a library,
This gives us a place to install packages that only some projects need,
or that are still under development,
without affecting the main installation (Figure \@ref(fig:py-rse-package-py-virtualenv).

```{r py-rse-package-py-virtualenv, echo=FALSE, fig.cap="Virtual Environments"}
knitr::include_graphics("figures/FIXME.png")
```

We can create and manage virtual environments using `conda`,
the same tool we used to install packages earlier.
We can create a new virtual environment called `zipf` with the `conda create` command
and specify the environment name with the `-n` or `--name` flag:

```shell
$ conda create -n zipf
```

```text
Collecting package metadata (current_repodata.json): done
Solving environment: done

## Package Plan ##

  environment location: /home/amira/anaconda3/envs/zipf



Proceed ([y]/n)? y

Preparing transaction: done
Verifying transaction: done
Executing transaction: done
#
# To activate this environment, use
#
#     $ conda activate zipf
#
# To deactivate an active environment, use
#
#     $ conda deactivate
```

`conda` creates the directory `~/anaconda3/envs/zipf`,
which contains subdirectories called `bin`, `lib`, and so on — everything
needed for a minimal Python installation.
Crucially,
`~/anaconda3/envs/zipf/bin/python` checks for packages in these directories
instead of checking the system-wide install.

We can switch to the `zipf` environment by running:

```shell
$ conda activate zipf
```

Once we have done this,
we're running the Python interpreter in `zipf/bin`:

```shell
(zipf)$ which python
```

```text
/home/amira/anaconda3/envs/zipf/bin/python
```

Notice how every command now displays `(zipf)` when that virtual environment is active.
Between Git branches and virtual environments,
it can be very easy to lose track of what exactly you're working on and with.
Having prompts like this can make it a little less confusing;
using virtual environment names that match the names of your projects
(and branches, if you're testing different environments on different branches)
quickly becomes essential.

We can now install packages to our heart's delight.
Everything we install will go under `zipf`,
and won't affect the underlying Python installation.
When we're done,
we can switch back to the default environment with `conda deactivate`.

```shell
(zipf)$ conda deactivate

```
```shell
$ which python
```

```text
/usr/bin/python
```

## How can I install my package? {#py-rse-package-py-installing}

Let's proceed to install our package inside this virtual environment.
First we need to activate it again:

```shell
$ conda activate zipf
```

Now the prompt should have changed to `(zipf)$` again.
From now on,
everything we do will be in this environment,
but we will simply type `$` from now on for brevity.

Let's change to the `zipf` directory containing our `setup.py` file
and install our package by typing `pip install -e .`,
where `.` references the current directory.
The `-e` flag indicates that we want to to install the package in "editable" mode,
which means that any changes we make in the package code are directly available to use
without having to reinstall the package.

```text
$ cd zipf
$ pip install -e .
```

```text
Processing /home/amira/proj/merely-useful.github.io/zipf/bin/zipf
Building wheels for collected packages: zipf
  Building wheel for zipf (setup.py) ... done
  Created wheel for zipf: filename=zipf-0.1-py3-none-any.whl size=4574 sha256=b7d645f1d07775714855a83d0cc62911c8502eb917fcb3fe2d9fe46206c84656
  Stored in directory: /tmp/pip-ephem-wheel-cache-19cuetii/wheels/a8/a6/0e/8b2a5cbf87d4a33551e65bc911bfdee49a4c117b0c5c834a47
Successfully built zipf
Installing collected packages: zipf
Successfully installed zipf-0.1
```

Success!
If you take a look in `~/anaconda3/envs/zipf/lib/python3.8/site-packages/`,
you will now see the `zipf` package with all the other site packages.


> [**`pip` and `conda`**][pip-and-conda]
>
> `pip` and `conda` can install packages from their respective online repositories.
> Whereas `pip` only installs Python packages,
> `conda` can install packages written in other language,
> which can facilitate installations of Python packages that relies on underlying C or Fortran libraries
> (such as `numpy`).
> `conda` packages are always distributed as binaries,
> which reduces installation times
> and `conda` is also capable of creating isolated Python environments.
> Creating packages compatible with `pip` is simpler than creating `conda` packages,
> and it is practical for installing local packages,
> which is how we are using it here.
> Once a package has been uploaded to PyPI,
> which we will go through later in this chapter,
> it can be converted to a `conda` package [in a few steps][conda-skeleton-pypi].
> Generally,
> you don't want to mix using `pip` and `conda`,
> but mainly rely on one package manager
> and only use the other one if needed.

If you try to run the package at this stage,
you will see that it complains that some of the packages we use,
such as pandas,
are not installed.
We could install these manually,
but it is preferred to automate this process
by listing all the required packages as dependencies of our package
using the `install_requires` parameter in `setup.py`:

```python
from setuptools import setup


setup(
    name='zipf',
    version='0.1',
    author='Amira Khan',
    packages=['zipf'],
    install_requires=[
        'matplotlib',
        'pandas',
        'scipy',
        'pyyaml'])  # Note the diff name from the import
```

We don't have to list `numpy` explicitly
since it will be installed as a dependency for `pandas` and `scipy`.
It is good practice to specify limits for the version numbers of the dependencies.For example,
if we have only tested our package on pandas version 1.0.1,
we could put `pandas==1.0.1` or `pandas>=1.0.1` instead of just `pandas`
in the list argument passed to the `install_requires` parameter.
Now we can install our package and all its dependencies in a single command:

```shell
$ pip install .
```

```text
Obtaining file:///home/amira/zipf
Collecting matplotlib
  Downloading matplotlib-3.2.1-cp37-cp37m-manylinux1_x86_64.whl (12.4 MB)
     |████████████████████████████████| 12.4 MB 1.9 MB/s
Collecting pandas
  Downloading pandas-1.0.3-cp37-cp37m-manylinux1_x86_64.whl (10.0 MB)
     |████████████████████████████████| 10.0 MB 16.1 MB/s
Collecting scipy
  Downloading scipy-1.4.1-cp37-cp37m-manylinux1_x86_64.whl (26.1 MB)
     |████████████████████████████████| 26.1 MB 11.4 MB/s
Requirement already satisfied: pyyaml in /home/amira/anaconda3/envs/zipf/lib/python3.7/site-packages (from zipf==0.1) (5.3.1)
Collecting pyparsing!=2.0.4,!=2.1.2,!=2.1.6,>=2.0.1
  Using cached pyparsing-2.4.6-py2.py3-none-any.whl (67 kB)
Collecting python-dateutil>=2.1
  Using cached python_dateutil-2.8.1-py2.py3-none-any.whl (227 kB)
Collecting kiwisolver>=1.0.1
  Downloading kiwisolver-1.2.0-cp37-cp37m-manylinux1_x86_64.whl (88 kB)
     |████████████████████████████████| 88 kB 8.6 MB/s
Collecting cycler>=0.10
  Using cached cycler-0.10.0-py2.py3-none-any.whl (6.5 kB)
Collecting numpy>=1.11
  Downloading numpy-1.18.2-cp37-cp37m-manylinux1_x86_64.whl (20.2 MB)
     |████████████████████████████████| 20.2 MB 16.3 MB/s
Requirement already satisfied: pytz>=2017.2 in /home/amira/anaconda3/envs/zipf/lib/python3.7/site-packages (from pandas->zipf==0.1) (2019.3)
Requirement already satisfied: six>=1.5 in /home/amira/anaconda3/envs/zipf/lib/python3.7/site-packages (from python-dateutil>=2.1->matplotlib->zipf==0.1) (1.14.0)
Installing collected packages: pyparsing, python-dateutil, kiwisolver, cycler, numpy, matplotlib, pandas, scipy, zipf
  Running setup.py develop for zipf
Successfully installed cycler-0.10.0 kiwisolver-1.2.0 matplotlib-3.2.1 numpy-1.18.2 pandas-1.0.3 pyparsing-2.4.6 python-dateutil-2.8.1 scipy-1.4.1 zipf
```

Note that the output will be similar to the above,
but not identical,
since package versions might change.

We could now import the functionality from our package inside Python code,
such as in a script or Jupyter notebook.
For example,
to use the function in `mymodule`,
we would write the following:

```python
from zipf import mymodule


mymodule.collection_to_csv(...)
```

However,
one downside of our packaging is that the useful command-line
scripts that we used to count and plot word counts,
are no longer accessible directly from the terminal.
Fortunately,
the `setuptools` package allows us to install not only the Python package itself,
but also associated scripts that it places with other executable files.
We can make sure that `setuptools` will install the scripts
by defining entry points[entry-points]:

```python
from setuptools import setup


setup(
    name='zipf',
    version='0.1',
    author='Amira Khan',
    packages=['zipf'],
    install_requires=[
        'matplotlib',
        'pandas',
        'scipy',
        'pyyaml'],
    entry_points={
        'console_scripts': [
            'countwords = zipf.countwords:main',
            'collate = zipf.collate:main',
            'plotcounts = zipf.plotcounts:main']})
```

The right side of the `=` operator is the location of a function (`package.module:function`),
and the left side is the name we want to use to call this function from the command line.
Let's remove our currently installed version of `zipf`
and install it again with the updated setup file.

```shell
$ pip uninstall zipf
```

```text
Found existing installation: zipf 0.1
Uninstalling zipf-0.1:
  Would remove:
    /home/amira/.local/lib/python3.8/site-packages/zipf.egg-link
Proceed (y/n)? y
  Successfully uninstalled zipf-0.1
```

```shell
$ pip install -e .
```

```text
Defaulting to user installation because normal site-packages is not writeable
Obtaining file:///home/amira/zipf
Requirement already satisfied: matplotlib in /usr/lib/python3.8/site-packages (from zipf==0.1) (3.2.1)
Requirement already satisfied: pandas in /home/amira/.local/lib/python3.8/site-packages (from zipf==0.1) (1.0.3)
Requirement already satisfied: scipy in /usr/lib/python3.8/site-packages (from zipf==0.1) (1.4.1)
Requirement already satisfied: pyyaml in /usr/lib/python3.8/site-packages (from zipf==0.1) (5.3.1)
Requirement already satisfied: cycler>=0.10 in /usr/lib/python3.8/site-packages (from matplotlib->zipf==0.1) (0.10.0)
Requirement already satisfied: kiwisolver>=1.0.1 in /usr/lib/python3.8/site-packages (from matplotlib->zipf==0.1) (1.1.0)
Requirement already satisfied: numpy>=1.11 in /usr/lib/python3.8/site-packages (from matplotlib->zipf==0.1) (1.18.2)
Requirement already satisfied: pyparsing!=2.0.4,!=2.1.2,!=2.1.6,>=2.0.1 in /usr/lib/python3.8/site-packages (from matplotlib->zipf==0.1) (2.4.6)
Requirement already satisfied: python-dateutil>=2.1 in /usr/lib/python3.8/site-packages (from matplotlib->zipf==0.1) (2.8.1)
Requirement already satisfied: pytz>=2017.2 in /usr/lib/python3.8/site-packages (from pandas->zipf==0.1) (2019.3)
Requirement already satisfied: six in /usr/lib/python3.8/site-packages (from cycler>=0.10->matplotlib->zipf==0.1) (1.14.0)
Requirement already satisfied: setuptools in /usr/lib/python3.8/site-packages (from kiwisolver>=1.0.1->matplotlib->zipf==0.1) (46.1.3)
Installing collected packages: zipf
  Running setup.py develop for zipf
Successfully installed zipf
```

The output looks slightly different this time
because pip did not need to go online to fetch the repositories,
since there was a local cached version from the previous install.

Now we can use our commands directly from the terminal
without writing the full path to the file
and without prefixing it with `python`.

```shell
countwords ../data/dracula.csv -n 5
```

```text
the,7474
and,5803
I,4846
to,4662
of,3707
```

## What does it mean to install a Python package? {#py-rse-package-py-installation}

Now that we have created and installed our very first Python package,
let's explore what actually happens during the installation of a package.

In essence,
installing a package means that the contents of the package are copied
into one of the directories that Python will search in.
This means that you can "install" packages
by manually copying source code into the right places
but it's much more efficient and safer
to use a tool specifically made for this purpose,
such as `conda` or `pip`.

Most commonly when installing packages,
they will be copied into the `site-packages` directory,
but this is not the only directory Python searches.
Just as the `PATH` environment in the shell contains a list of directories
that the shell searches for programs it can execute,
the Python variable `sys.path` contains a list of the directories to search.
We can see the which directories Python looks in,
by opening the Python interpreter and typing the following.

```python
import sys


sys.path
```

```
['',
'/home/amira/anaconda3/envs/zipf/lib/python37.zip',
'/home/amira/anaconda3/envs/zipf/lib/python3.7',
'/home/amira/anaconda3/envs/zipf/lib/python3.7/lib-dynload',
'/home/amira/.local/lib/python3.7/site-packages',
'/home/amira/anaconda3/envs/zipf/lib/python3.7/site-packages',
'/home/amira/zipf']
```

The first will be your current directory,
and the rest are system paths for
the Python installation you are using.
This might differ slightly on different systems.


## How can I distribute software packages that I have created? {#py-rse-package-py-distribute}

With our package working, testable, installable, and documented,
we should distribute it so anyone can just `pip install zipf`
and start running!

To create a package that can be installed by `pip`
we first need to create a source distribution
(an `sdist` in Python packaging jargon)
using setuptools:

```shell
python setyp.py sdist
```

```text
running sdist
running egg_info
writing zipf.egg-info/PKG-INFO
writing dependency_links to zipf.egg-info/dependency_links.txt
writing entry points to zipf.egg-info/entry_points.txt
writing requirements to zipf.egg-info/requires.txt
writing top-level names to zipf.egg-info/top_level.txt
package init file 'zipf/__init__.py' not found (or not a regular file)
reading manifest file 'zipf.egg-info/SOURCES.txt'
writing manifest file 'zipf.egg-info/SOURCES.txt'
running check
warning: check: missing required meta-data: url

warning: check: missing meta-data: if 'author' supplied, 'author_email' must be supplied too

creating zipf-0.1
creating zipf-0.1/zipf
creating zipf-0.1/zipf.egg-info
copying files to zipf-0.1...
copying README.md -> zipf-0.1
copying setup.py -> zipf-0.1
copying zipf/collate.py -> zipf-0.1/zipf
copying zipf/countwords.py -> zipf-0.1/zipf
copying zipf/mymodule.py -> zipf-0.1/zipf
copying zipf/plotcounts.py -> zipf-0.1/zipf
copying zipf.egg-info/PKG-INFO -> zipf-0.1/zipf.egg-info
copying zipf.egg-info/SOURCES.txt -> zipf-0.1/zipf.egg-info
copying zipf.egg-info/dependency_links.txt -> zipf-0.1/zipf.egg-info
copying zipf.egg-info/entry_points.txt -> zipf-0.1/zipf.egg-info
copying zipf.egg-info/requires.txt -> zipf-0.1/zipf.egg-info
copying zipf.egg-info/top_level.txt -> zipf-0.1/zipf.egg-info
Writing zipf-0.1/setup.cfg
creating dist
Creating tar archive
removing 'zipf-0.1' (and everything under it)
```

These distribution files can now be distributed via PyPI,
the standard Python repository for Python packages.
There is a TestPyPI repository that lets us test putting packages on PyPI
without having them appear on the standard repository;
let's start with that.
Go to [test.pypi.org](https://test.pypi.org),
create an account,
and confirm your email.

The preferred tool for uploading packages to PyPI is called [twine][twine];
we will install that package:

```shell
$ pip install twine
```
and now we can upload our distributions from the `dist/` folder:

```shell
$ twine upload --repository-url https://test.pypi.org/legacy/ dist/*
Enter your username: amirakhan
Enter your passowrd: *********
Uploading distributions to https://test.pypi.org/legacy/
Uploading zipf-0.1.tar.gz
100%|█████████████████| 5.59k/5.59k [00:01<00:00, 3.27kB/s]

View at:
https://test.pypi.org/project/zipf/0.1/
```

The `--repository-url` allows us to specify the TestPyPI repository, and we
have now uploaded both types of distribution, allowing users with different
environments to use the wheel distribution if their systems allow it, or
the source distribution otherwise.

We can now test this with a virtual environment and installing with pip:

```shell
$ conda create -n zipf-test
$ conda activate zipf-test
(zipf-test)$ pip install --index-url https://test.pypi.org/simple zipf
```

```text
Looking in indexes: https://test.pypi.org/simple
Collecting zipf
  Downloading https://test-files.pythonhosted.org/packages/aa/fb/352af20b6f4bb13c3f06e7c2f1e1b7ec8a11e771533d5ad05407d48059a9/zipf-0.1.tar.gz (3.1 kB)
Requirement already satisfied: matplotlib in /usr/lib/python3.8/site-packages (from zipf) (3.2.1)
Requirement already satisfied: pandas in ./.local/lib/python3.8/site-packages (from zipf) (1.0.3)
Requirement already satisfied: scipy in /usr/lib/python3.8/site-packages (from zipf) (1.4.1)
Requirement already satisfied: pyyaml in /usr/lib/python3.8/site-packages (from zipf) (5.3.1)
Requirement already satisfied: cycler>=0.10 in /usr/lib/python3.8/site-packages (from matplotlib->zipf) (0.10.0)
Requirement already satisfied: kiwisolver>=1.0.1 in /usr/lib/python3.8/site-packages (from matplotlib->zipf) (1.1.0)
Requirement already satisfied: numpy>=1.11 in /usr/lib/python3.8/site-packages (from matplotlib->zipf) (1.18.2)
Requirement already satisfied: pyparsing!=2.0.4,!=2.1.2,!=2.1.6,>=2.0.1 in /usr/lib/python3.8/site-packages (from matplotlib->zipf) (2.4.7)
Requirement already satisfied: python-dateutil>=2.1 in /usr/lib/python3.8/site-packages (from matplotlib->zipf) (2.8.1)
Requirement already satisfied: pytz>=2017.2 in /usr/lib/python3.8/site-packages (from pandas->zipf) (2019.3)
Requirement already satisfied: six in /usr/lib/python3.8/site-packages (from cycler>=0.10->matplotlib->zipf) (1.14.0)
Requirement already satisfied: setuptools in /usr/lib/python3.8/site-packages (from kiwisolver>=1.0.1->matplotlib->zipf) (46.1.3)
Installing collected packages: zipf
    Running setup.py install for zipf ... done
Successfully installed zipf-0.1
```

Success,
You can see that `pip` took advantage of the fact that some packages already existing on our system,
and didn't download these again.
Once we are happy with how our package appears in TestPyPI
(including its [project page](https://test.pypi.org/project/zipf/)),
we can go through the same process to put it on the main PyPI repository
at [pypi.org](https://pypi.org/).
But first we have a few improvements to make to our `setup.py` so that
our package webpage is useful and to make it easier for potential users
to find, understand, and install our package.

> If you are building larger projects,
> it is beneficial to not only distribute a source distribution
> but also a binary one since this will be faster for users to install.
> Binary distributions can be build with `python setup.py bdist`.
> They are platform specific and often referred to as [wheels][wheels].

## How should I document my package for others? {#py-rse-package-py-document}

Writing good documentation does not have to be time-consuming
and involve learning new tools.
Here we will mention the bare necessities for creating great documentation
and then highlight extensions that are useful for more complex projects.

Documentation starts with writing clear explanatory docstrings for each function and module,
which we have already done.
This is one of the most important steps,
since it means that others can understand what each function is meant to do,
without going through the source code.

What is missing is an introduction to what our package is meant to do,
instructions on how to install it,
and some examples of how it can be used.
We can include these elements in the README.md.
An example of a good README.md file for our project would be


````markdown
# zipf

The `zipf` package tallies the occurrences of words in text files
and plots each word's rank versus its frequency
together with a line for the theoretical distribution for Zipf's Law.

## Motivation

Zipf’s Law is often stated as an observational pattern seen in the
relationship between the frequency and rarity of words in a text:

> "…the most frequent word will occur approximately twice as often as
> the second most frequent word, three times as often as the third most
> frequent word, etc."
> — <https://en.wikipedia.org/wiki/Zipf%27s_law>

As many books are available to download in plain text format,
e.g from https://www.gutenberg.org/,
we created this package to qualitative explore how well authors align
with the word frequencies predicted by Zipf's Law.

## Installation

For now,
this package can be installed by downloading the package directory
and running `pip install .` from inside the `zipf` folder.
It will soon be available for download directly via `pip`,
stay tuned!

## Usage

After installing this package,
the following three commands will be available from the command line

- `countwords` for counting the occurrences of words in a text.
- `collate` for collating multiple word count files together.
- `plotcounts` for visualizing the word counts.

A typical usage scenario would include running the following from your terminal.

```shell
countwords dracula.txt > dracula.csv
countwords moby_dick.txt > moby_dick.csv
collate dracula.csv moby_dick.csv > collated.csv
plotcounts collated.csv --outfile zipf-drac-moby.jpg
```

The output file would look something like

![]image ref


Additional information on each function can be found in their docstrings and appending the `-h` flag,
e.g. `countwords -h`.
````

For simple packages,
carefully written docstrings and READMEs
are sufficient to describe the package
and is infinitely better than not documenting your package at all.
As you code base grows larger,
it will become convenient to complement these manually written sections
with automatically generated content,
references between functions,
and search functionality.
We will see how to do this next.

## Advanced docs

As we get our package ready for sharing with others, we should
make sure there's enough documentation written for our intended
initial users to successfully install the software and begin to
use key functionality.

Ideally we've been maintaining documentation throughout the development
process. But the documentation we keep through that process is often
intended for a different audience and purpose—that is, it's meant for
us while developing the code, and so includes things that are good and
useful like code comments reminding us why steps are taken, but may
not include overviews of the package and how (and why!) to use it, which
we largely take for granted.

We should certainly have a README for the package, describing how to
install the package and how to use it in a couple of key use cases,
so let's add that.

In the Python community, much documentation is written in
[reStructuredText][restructured-text], which is
a markup format for plain text documents which can be rendered
into documents with quite complex indexes and cross-linking
by many documentation tools; GitHub will recognize reST files
ending in `.rst` and display them nicely. We'll use that here;
titles are underlined and overlined, section headings are underlined,
and code blocks are set off with two colons (`::`) and indented.
So let's create a `README.rst`:

```text
======
Zipfpy
======

This python package provides routines for generating lists of counts
that follow (exactly or approximately) a Zipf distribution, and for
testing whether a counts distribution does or doesn't follow such
a distribution.

Installation
------------

To install, clone this repository, change into the repository directory
and run the commands::

    pip install -r requirements.txt
    pip install .

Use
---

You can use the package after installation with `import zipfpy`, with functions
in the modules `check` and `generate`.

You can also use the command line tool `check_zipf.py` which tests to see if
a provided list of countsfollows a Zipf distribution::

    $ check_zipf.py 100 50 33 25
    True: [100, 50, 33, 25]

Authors
-------

Terry Pratchett
```

In addition to the README, we should also make sure that there are
[docstrings](#docs-docstrings) written for the package as a whole
(in the `__init__.py`):

```python
"""
The zipfpy package contains tests of distributions of counts to see if
they follow a Zipf distribution (https://en.wikipedia.org/wiki/Zipf%27s_law)
using the routines in the check module, and routines for generating
lists of counts that follow a Zipf distribution in the generate module.
"""
RELATIVE_ERROR = 0.05
```

and for key routines like `is_zipf` and `make_zipf`:

```python
def is_zipf(hist, rel=RELATIVE_ERROR):
    """Tests if a histogram of counts follows a Zipf distribution.

    Given a list of counts as hist, assumed sorted in decreasing order,
    and a relative error tolerance (if not provided, the default value
    zipfpy.RELATIVE_ERROR is used), tests to see if the counts follow
    a Zipf distribution.

    Args:
        hist: an list or other iterable containing a list of numeric counts
        rel: the relative error tolerance used if provided; if not,
             the package default is used.

    Returns:
        True if the list of counts follows a zipf distribution within
        the relative tolerance.  False otherwise.

    Raises:
        AssertionError: raised if an empty list is passed.
    """
    assert len(hist) > 0, 'Cannot test Zipfiness without data'
    scaled = [h/hist[0] for h in hist]
    perfect = make_zipf(len(hist))
    return scaled == approx(perfect, rel=rel)
```

```python
def make_zipf(length):
    """Returns a list of counts that follows a Zipf distribution.

    Args:
        length: the number of counts to be generated

    Returns:
        A list of the provided length of floating point numbers corresponding
        exactly the zipf distribution.  For example, for length=5:

        [1.0, 0.5, 0.3333333333333333, 0.25, 0.2]

    Raises:
        AssertionError: raised if a zero or negative length is provided
    """
    assert length > 0, 'Zipf distribution must have at least one element'
    result = [1/(1 + i) for i in range(length)]
    return result
```

Not only is the documentation then useful for those reading the
code, but it helpfully shows up when a user types, for instance,
`help(zipfpy)`.

<!-- used="py-rse-package-py/09/requirements.txt" -->
<!-- used="py-rse-package-py/09/setup.py" -->
<!-- used="py-rse-package-py/09/test_zipf.py" -->

### How do I generate web pages of documentation for my package? {#py-rse-package-py-sphinx}

When you've viewed documentation for large Python packages, they
have very likely been prepared using [Sphinx](http://www.sphinx-doc.org/en/master/),
a package for writing software documentation and generating web packages
for that documentation that is widely used in the Python community.
When combined with [Read The Docs](https://readthedocs.org), a free service for
hosting that online documentation that includes tools to automatically update
documentation when your package and its documentation changes, and that understands
documents written to support Sphinx, it is an extremely useful way to
build both documentation and an online home for your package.  Both tools
recognize reStructuredText files.

We'll start by putting together a minimal set of documentation that includes
your `README.rst` and the docstrings for your package.  Sphinx makes it
relatively straightforwrd to get started, using the `quickstart` tool.  We'll
create doucmentation in a `docs/` directory at the top of our repository:

```bash
$ mkdir docs
$ cd docs
$ sphinx-quickstart
```

We'll be asked to specify the project's name, our (the author's) name, and
a release.  Otherwise we can mostly use the defaults, but we'll want
to use specfiy that we do want autodoc to automatically insert our docstrings:

```text
...
The project name will occur in several places in the built documentation.
> Project name: zipfpy
> Author name(s): Terry Pratchett
> Project release []: 1.0
...
> autodoc: automatically insert docstrings from modules (y/n) [n]: y
...
```

Once that is complete, there will be a file called `conf.py` in the docs
directory that configures Sphinx.  We'll make one change to that, so that
autodoc can find our module (and its docstrings).

First, we'll set the "Path setup" section, which starts very near the head
of the file:

```text
# -- Path setup --------------------------------------------------------------

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
```

Here we those extensions are in another directory, so we'll uncomment those
lines below and add another pointing up one level from `docs/` so that we have:

```python
import os
import sys


sys.path.insert(0, os.path.abspath('./'))
sys.path.insert(0, os.path.abspath('../'))
```

With that done, we can generate run a sphinx autodoc script which will read
the docstrings from our package and include them into .rst files in the
`docs/source` directory:

```bash
sphinx-apidoc -o source/ ../zipfpy
```

Now we're ready.  In the `/docs` directory there's a Makefile,
generated by `sphinx-quickstart`;
if we run `make html`
and in a web browser open the file `docs/_build/index.html` we'll have a very minimal
documentation in a familiar looking form; if you look under `modules` you will
see the documentation for the individual modules.  But that first page is
still a little sparse.

If we add the line `.. include:: ../README.rst` to the `docs/index.rst` file
at the beginning, so that page starts with our README, and then include a direct
link to the zipfpy package documentation:

```text
Welcome to Zipfpy's documentation!
==================================

.. include:: ../README.rst

.. toctree::
   :maxdepth: 2
   :caption: Contents:

   zipfpy

Indices and tables
==================

* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`
```

and rerun `make html`, we now get an updated set of web pages which
re-uses your README to be the introduction to the documentation.

Note that we needed additional packages to build the documentation
here that is not reflected in our `requirements.txt`; the `Sphinx`
package and its dependencies.

They aren't needed for running, developing, or even testing
the package, but it is needed for building the documentation.
To note this requirement, but without requiring everyone installing
the package to have `Sphinx`
installed, let's create a `requirements_docs.txt` file that contains
only those things (where versions come from `pip freeze`):

```text
Sphinx>=1.7.4
```

Then anyone wanting to build the documentation (including you, on another computer)
need only run `pip install -r requirement_docs.txt`

This breakdown of requirements by use case is often seen with packages
that have a `requirements_dev.txt` for additional packaged not needed
for users of the package, but for its development and testing.  For this
package, we could usefully pull out `pytest` from our `requirements.txt`
into a `requirements_dev.txt`

### How do I put the documentation for my package online? {#py-rse-package-py-rtd}

There are a number of ways of hosting the web pages that document
your project.  A very common option, particularly for Python
projects, is [Read The Docs](https://readthedocs.org), a community
supported site which hosts software documentation free of charge.

Read The Docs integrates nicely with GitHub, which will allow
you to have the documentation re-built automatically upon update
of your repository.  Thus we recommend
[registering for Read The Docs](https://readthedocs.org/accounts/signup/) with your GitHub
account.

Once you have registered for Read The Docs, confirmed your email, and signed in,
you will be able to add new projects by [importing a project](https://readthedocs.org/dashboard/import/?)
from your github repository; Read The Docs will then build the documentation
(_e.g._, run make) and host the resulting files.  For this to work, all of
the source files (in our case, `docs/source/modules.rst`, `docs/source/zipfpy.rst`,
`docs/Makefile`, `docs.conf.py`) need to be checked into your repository.

Then you should be able to build; after a few minutes, your documents should
be visible!  If you named your project, _e.g._, `pterry_zipfpy`, your
documents will be available at
[`https://pterry_zipfpy.readthedocs.io/en/latest/`](https://pterry_zipfpy.readthedocs.io/en/latest/).

As with [continuous integration with Travis-CI](integrate.html#integrate-basic),
GitHub works with ReadTheDocs so that if you have set up your ReadTheDocs project
with your GitHub account, changes to the documentation will automatically result
in the online documentation being rebuilt.

Also as with continuous integration testing, there are badges for your README linking
both to the documentation and reporting on the status of the documentation build;
you would be able to add that badge and link by adding the following line to your
`README.rst`:

```text
.. image:: https://pterry_zipfpy.readthedocs.io/en/latest/?badge=latest
    :target: https://readthedocs.org/projects/pterry_zipfpy/badge/?version=latest
    :alt: Documentation Status
```

Note the syntax for adding an image to a reST file; `.. image::` followed by the link
to the image, and additional, optional fields on indented lines, such as `:target:` for
a link to follow when the image is clicked, and `:alt:` for alternate text for the image.

### Announcing Work {#py-rse-package-py-announce}

FIXME: <https://medium.com/indeed-engineering/marketing-for-data-science-a-7-step-go-to-market-plan-for-your-next-data-product-60c034c34d55>

## Summary {#py-rse-package-py-summary}

```{r p-package-concept, echo=FALSE, fig.cap="Python Packaging Concept Map"}
if (knitr::is_latex_output()) {
  knitr::include_graphics("figures/rse-package-py/concept.pdf")
} else {
  knitr::include_graphics("figures/rse-package-py/concept.svg")
}
```

FIXME: summarize Python packaging chapter

## Key Points {#py-rse-package-py-keypoints}

```{r, child="keypoints/rse-package-py.md"}
```

## Exercises

### Exercises: Examining the virtual environment

1. If you haven't already, create a `test` virtual environment and activate it.  Your prompt should now start with `(test)`.
2. Run `pip list`. What packages are installed?
3. Run the `showpath.py` script from the earlier section, and note that the paths are different from your
base environment where you looked for packages.  They probably look like `/Users/pterry/envs/test/lib/python-3.7/site-packages`.
4. Pick a package you know you have installed in your base environment—pick `pytest` if you can't think of one—and
try to import it in a Python interpreter.  Can it be found?
5. Deactivate the environment and try again.

### Exercise: Hello, Zipf!

Put a statement

```python
print("Hello, Zipf!")
```
at the end of `zipf.py`.

1. What happens when you start Python interactively and import the
module with the command `import zipf`?
2. Python caches modules that have been imported.  What happens if you
type `import zipf` again?

### Exercise: What is `__name__` in different contexts?

1. Start an interactive Python interpreter, and run `print(__name__)`.
What do you get?
2. Add the statement `print(__name__)` to the end of the file `zipf.py`
and from the Python interpreter, run `import zipf`.  What is the name
printed?

### Exercise: Create a package for our Zipf code.

We're going to create a package for the code we've written
for the Zipf distribution.  In the long and honourable(?)
tradition of package names ending in "py", we'll call our
package zipfpy.

1. Create a `zipfpy` directory and move the file `zipf.py` into that directory.
2. Create an empty file `zipfpy/__init__.py`.
3. Modify the test suite so that it runs; functions will now be found in the [namespace][namespace] `zipfpy.zipf` rather than `zipf`.
4. Run the test suite with `pytest`

### Exercise: "Hello `__init__.py`"

Repeat the "Hello, Zipf!" exercise by temporarily adding the
line `print("Hello, Init!")` to the `__init__.py`.  Then
from the directory containing the directory `zipfpy`, start
a Python interpreter and run:

```python
import zipfpy
```

What happens?

When you're done, remove the `print()` line from `__init__.py`.


### Exercise: Factor out the package-wide constant `RELATIVE_ERROR`

It's perfectly valid for an `__init__.py` file to be empty,
but it is also a very useful place to put definitions that are
common to the entire package.

Here, both `generate` and `check` use the same default `RELATIVE_ERROR`;
let's move that into `__init__.py`:

1. Add the line `RELATIVE_ERROR = 0.05` to `__init__.py`;
2. Now we can remove the line definining `RELATIVE_ERROR` from `check.py`
and `generate.py`, but;
3. We still need to import that definition somehow, or else those functions
won't know what a `RELATIVE_ERROR` is; add the line `from . import RELATIVE_ERROR`
to each so that it is visible.  When we don't specify a file, it imports the
definition from `__init__.py` (just as `import zipfpy` will read the `__init__.py`)
4. Run the test suite with `pytest`

We haven't shortened the code any here—we've replaced a `RELATIVE_ERROR = 0.05`
with an `from . import RELATIVE_ERROR`—but now the constant is defined in only
one location so we don't have to worry about editing it in one location and that
value being out of sync in the other.

### Exercise: Importing from within __init__.py

Since any code that does an `import zipf` will read `__init__.py`, it
can be convenient to put import statments in `__init__.py` itself, to
ensure that some key definitions are readily available when the package
is imported.

We'll try that here:

1. Add the lines `from .generate import *` and `from .check import *` to
`zipfpy/__init__.py`.
2. In the test suite, you can now call `import zipfpy` and refer to,
_e.g._, `zipfpy.make_zipf(...)` instead of `zipfpy.generate_make_zipf(...)`.
Make those changes
3. Run the test suite with `pytest`

Note that it doesn't make sense to import absolutely everything like we
have here into the `zipfpy` namespace—it kind of defeats the purpose
of having split up the files—but for a modest number of key definitions
this can be very convenient for the package users.

4. Undo the changes you made in 1. and 2., and make sure the test suite
still runs.

### Exercise: Clean up warning messages

-   FIXME: clean up warning messages from `python setup.py sdist`

### Exercise License, longinfo, and classification metadata

-   FIXME: add additional metadata to setup.py

### Exercise: Requirements in setup.py

-   FIXME: add requirements metadata to setup.py


### Exercise: Find a package in pip list

The `pip list` command will generate a list of Python packages
installed using pip in the current environment.  Here we'll find
a package that we've recently installed.

1.  Run `pip list`, and from the list pick something that you've
installed recently; if you can't think of anything, choose `pytest`.
2.  Run the `showpath.py` script to show the list of paths the package could be in.
3.  Search the paths in 2. for files corresponding to the package you choose in 1.;
`site-packages` is normally a good place to start looking.

### Exercises: Installing a package into the virtual environment


1. Re-activate the `test` virtual environment from above, and if necessary,
re-run the `showpath.py` script.
2. Let's install a simple package, `click`; it's a commonly used package for
creating simple command-line tools, but for our purposes it's just a small
self-contained package.  Run `pip install click`.
3. Search in the directories output from `showpath.py` for a package named `click`;
it will be a directory containing an `__init__.py`.
4. Start a Python interpreter, and run `import click`; it is installed in the environment.
5. From that same interpretter, run `print(click.path)`; that is the path to the click package.
It should report the same directory that you found it in.
6. Exit the Python interpretter

Now let's just clarify that the environment is different than the directory you
installed the virtual environment contents in:

1. Start another terminal, and go to the directory containing the `test` virtual environment contents.
2. Run the `showpath.py` script - does it show the directories in the base environment or the virtual environment?
3. Start a Python interpretter, and try `import click`.
4.
    a. If you didn't have `click` installed in the base environment, this will fail.
    b. If you did have `click` installed in the base environment, this will be successful, but the click path will be different: `print(click.__path__)` to verify.
5. Exit the Python interpreter, and deactivate the `test` environment in the other terminal.


```{r, child="./links.md"}
```
